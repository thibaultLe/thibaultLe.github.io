<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Thibault Lechien</title>
  <meta name="description" content="Personal website of Thibault Lechien. PhD Researcher at Max Planck Institute for Astrophysics | AI for Astrophysics.">

  <link rel="icon" href="/assets/galaxy.png">
  <link rel="icon" type="image/x-icon" href="/assets/galaxy.png">

  <link rel="stylesheet" href="stylesheets/styles.css">
  <link rel="stylesheet" href="stylesheets/pygment_trac.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">


  <style>
    /* Light theme (default) */
    :root {
      --background-color: #fff;
      --text-color: #000;
    }

    /* Dark theme */
    [data-theme="dark"] {
      --background-color: #1f1f1f;
      --text-color: #fff;
    }

    body {
      background-color: var(--background-color);
      color: var(--text-color);
    }

    header h1, header p, section h1, section h2, section p {
      color: var(--text-color);
    }

    /* Theme switch styles */
    .theme-switch-wrapper {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 100;
    }

    :root {
      --toggleHeight: 2em;
      --toggleWidth: 3.75em;
      --toggleBtnRadius: 1.25em;
      --bgColor--night: #423966;
      --mooncolor: #D9FBFF;
      --bgColor--day: #9ee3fb;
    }

    .tdnn {
      margin: 0 auto;
      font-size: 100%;
      position: relative;
      height: var(--toggleHeight);
      width: var(--toggleWidth);
      border-radius: var(--toggleHeight);
      transition: all 500ms ease-in-out;
      background: var(--bgColor--night);
      cursor: pointer;
    }

    .day {
      background: #FFBF71;
    }

    .moon {
      position: absolute;
      display: block;
      border-radius: 50%;
      transition: all 400ms ease-in-out;
      top: 0.375em;
      left: 0.375em;
      transform: rotate(-75deg);
      width: var(--toggleBtnRadius);
      height: var(--toggleBtnRadius);
      background: var(--bgColor--night);
      box-shadow:
        0.375em 0.3125em 0 0em var(--mooncolor) inset,
        rgba(255, 255, 255, 0.1) 0em -0.875em 0 -0.5625em,
        rgba(255, 255, 255, 0.1) 0.375em 0.875em 0 -0.5625em,
        rgba(255, 255, 255, 0.1) 0.25em 1.625em 0 -0.5em,
        rgba(255, 255, 255, 0.1) 0.75em 0.25em 0 -0.5125em,
        rgba(255, 255, 255, 0.1) 1em 1em 0 -0.5625em,
        rgba(255, 255, 255, 0.1) 0.75em 1.625em 0 -0.5625em,
        rgba(255, 255, 255, 0.1) -0.5em 0.875em 0 -0.5625em,
        rgba(255, 255, 255, 0.1) -0.125em 1.25em 0 -0.5625em;
    }

    .sun {
      top: 0.5625em;
      left: 2.25em;
      transform: rotate(0deg);
      width: 0.875em;
      height: 0.875em;
      background: #fff;
      box-shadow: 0.375em 0.375em 0 0.625em #fff inset,
        0 -0.625em 0 -0.3375em #fff,
        0.4375em -0.4375em 0 -0.375em #fff,
        0.625em 0 0 -0.3375em #fff,
        0.4375em 0.4375em 0 -0.375em #fff,
        0 0.625em 0 -0.3375em #fff,
        -0.4375em 0.4375em 0 -0.375em #fff,
        -0.625em 0 0 -0.3375em #fff,
        -0.4375em -0.4375em 0 -0.375em #fff;
    }

    /* Add or update the button container styles */
    .button-container {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .linkedin-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .linkedin-button img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      filter: brightness(0);  /* Makes images black in light mode */
    }

    /* Exclude ORCID from color filtering */
    .linkedin-button img[alt="Orcid ID"] {
      filter: none !important;
    }

    /* Make other icons white in dark mode, but still exclude ORCID */
    [data-theme="dark"] .linkedin-button img:not([alt="Orcid ID"]) {
      filter: brightness(100);
    }

    /* Update font sizes */
    header h1 {
      font-size: 28px;  /* Increased from 24px */
      margin-bottom: 10px;
    }

    header p {
      font-size: 18px;  /* Increased from 16px */
    }

    section h1 {
      font-size: 24px;  /* Increased from 22px */
    }

    section h2 {
      font-size: 20px;  /* Increased from 18px */
    }

    section p, section li {
      font-size: 16px;  /* Increased from 14px */
    }

    /* Adjust link size in header */
    header a {
      font-size: 16px;  /* Increased from 14px */
    }

    /* Make all links lighter blue in dark mode */
    [data-theme="dark"] a {
      color: #63c0f5;  /* Lighter blue color for better visibility in dark mode */
    }

    /* Remove default underlines from all links */
    a {
      text-decoration: none;
    }

    /* Add underline only on hover */
    a:hover {
      text-decoration: underline;
    }

    /* Make tooltips appear faster - only for social media buttons */
    .linkedin-button[title] {
      position: relative;
    }

    .linkedin-button[title]:hover::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 1000;
      margin-bottom: 5px;
      animation: fadeIn 0.1s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Header background */
    header {
      background-color: rgba(0, 0, 0, 0.1);
      padding: 20px;
      border-radius: 6px;
      margin-bottom: 10px;
    }

    /* Dark theme header background */
    [data-theme="dark"] header {
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* Progress bar styles */
    .progress {
      position: relative;
    }

    .progress-text {
      position: absolute;
      width: 100%;
      text-align: center;
      left: 0;
      right: 0;
      color: #000;  /* Always dark text */
    }

    /* Remove or comment out this rule since we want the text to stay dark */
    /*[data-theme="dark"] .progress-text {
      color: #fff;
    }*/

  </style>



</head>

<body>
  <div class="theme-switch-wrapper">
    <div class="tdnn">
      <div class="moon">
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>

  <div class="wrapper">
    <header>
      <h1>Thibault Lechien</h1>
      <p>PhD Student <br> Max Planck Institute for Astrophysics</p>
      <img src="/assets/IMG_1624.jpg" alt="Thibault Lechien's Photo">
      <p></p>


      <!-- Container for buttons -->
      <div class="button-container">

        <a class="linkedin-button" href="https://www.linkedin.com/in/tlechien" target="_blank" title="LinkedIn">
          <img src="/assets/linkedinwhite.png" alt="Linkedin">

        </a>


        <a class="linkedin-button" href="https://www.researchgate.net/profile/Thibault-Lechien-2" target="_blank" title="ResearchGate">
          <img src="/assets/RGlogowhite.png" alt="ResearchGate">

        </a>

        <a class="linkedin-button" href="https://scholar.google.be/citations?user=ohWNXuEAAAAJ&hl=en&oi=ao"
          target="_blank" title="Google Scholar">
          <img src="/assets/Gscholarblackwhite.png" alt="Google Scholar">
        </a>

        <a class="linkedin-button" href="https://orcid.org/0000-0001-6284-2842"
          target="_blank" title="ORCID profile">
          <img src="/assets/orcid.logo.icon.svg" alt="Orcid ID">
        </a>

      </div>

      <p></p>



      <!-- CV button -->
      <p> <b><a href="/assets/CV.pdf" target="_blank"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/></svg>View my CV</a></b></p>



      <p></p>
      <p><a href="mailto:lechien@mpa-garching.mpg.de"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 8px; vertical-align: middle;"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>lechien@mpa-garching.mpg.de</a></p>

    </header>
    <section>
      <h1>AI for Astrophysics</h1>

      <p> I am a PhD student at the <a href="https://www.mpa-garching.mpg.de/" title="Max Planck Institute for Astrophysics">Max Planck Institute for Astrophysics</a> working on "Advancing stellar and binary evolution using machine learning" with Prof. <a href="https://www.selmademink.com/" title="Selma de Mink">Selma de Mink</a>.
        I was previously a Research Assistant in the <a href="https://science.gsfc.nasa.gov/astrophysics/astroparticles/" title="Astroparticle Physics Lab">Astroparticle Physics Lab</a> and
        the <a href="https://science.gsfc.nasa.gov/astrophysics/gravity/" title="Gravitational Astrophysics Lab">Gravitational Astrophysics Lab</a>
        at <a href="https://www.nasa.gov/goddard/" title="NASA Goddard">NASA Goddard Space Flight Center</a>.
        I have an MSc. in Computer Science from <a href="https://www.kuleuven.be/english/kuleuven/index.html" title="KU Leuven">KU Leuven</a> and research experience in applying AI to astrophysics in numerous projects at NASA and ESA.</p>



      <h2>Research interests</h2>
      <p>My current research interests involve solving interesting inverse problems in astrophysics.
      Coming from a computational science background, I see a huge potential for AI methods to be applied to these problems.
      Traditional (non-AI) methods are often too inefficient, cannot handle large datasets or suffer from analytic degeneracies.
      With the incoming wave of data from the current and future astronomical campaigns, astrophysics needs new methodologies.  </p>

      <h2>Past projects</h2>
      <ul>
        <li>During the first year of my PhD, we showed that when stars throw mass onto a companion star that is orbiting closely, this companion accretes a lot of the transferred mass. This is in direct conflict with commonly used theoretical models, which is why it was surprising! <a href="https://doi.org/10.48550/arXiv.2505.14780" title="https://doi.org/10.48550/arXiv.2505.14780">[doi.org/10.48550/arXiv.2505.14780]</a>.</li>
        <li>At NASA Goddard Space Flight Center, I did research on neutron star X-ray and Gamma-ray emission. In particular, we inferred the mass, radius and magnetic field geometry of neutron stars from <a href="https://science.nasa.gov/mission/nicer/" title="NICER">NICER</a>
          and <a href="https://fermi.gsfc.nasa.gov/" title="Fermi">Fermi</a> data using neural networks emulators, speeding up simulations by 7 orders of magnitude at a minimal loss in accuracy.  </li>
        <li>At ESA's Advanced Concepts Team, I implemented a novel approach to reconstruct Dark Matter distributions from stellar orbits in the Galactic Centre,
          eliminating the need to make assumptions on the physical composition of the Dark Matter distribution
          <a href="https://doi.org/10.1051/0004-6361/202347738" title="doi.org/10.1051/0004-6361/202347738">[doi.org/10.1051/0004-6361/202347738]</a>. </li>
        <li>As part of an Honour's project at KU Leuven, I constructed a neural network to reconstruct spectral functions (and complex poles) of confined particles in high energy physics. This generalized upon previous approaches and achieved state of the art performance on genuine lattice data <a href="https://scipost.org/SciPostPhys.13.4.097/pdf" title="https://scipost.org/SciPostPhys.13.4.097/pdf">[SciPostPhys.13.4.097]</a>. </li>
      </ul>

      <h2>Past talks</h2>
      <p>Talk at the Center for Astrophysics | Harvard & Smithsonian as part of the AstroAI workshop:</p>
      <div style="position: relative; width: 100%; height: 0; padding-bottom: 56.25%; margin-bottom: 1rem;">
        <iframe
          src="https://www.youtube.com/embed/v-tlV2J0nCU?start=50"
          title="YouTube video"
          style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
          allowfullscreen>
        </iframe>
      </div>

      <h2>PhD progress bar</h2>
      <div class="progress" role="progressbar" aria-label="Info striped example" aria-valuenow="3" aria-valuemin="0" aria-valuemax="100">
        <div class="progress-bar progress-bar-striped bg-info" id="progressBar" style="width: 3%">
          <div class="progress-text" id="progressText">2%</div>
        </div>
      </div>

      <script>
        // PhD start date and duration in milliseconds (4 years)
        const phdStartDate = new Date('2024-10-01');
        const phdEndDate = new Date('2028-10-01');

        // Cache DOM elements
        const progressBar = document.querySelector('.progress-bar');
        const progressText = document.getElementById('progressText');

        // Function to update progress
        function updateProgress() {
            const now = new Date();
            const totalDuration = phdEndDate - phdStartDate;
            const elapsed = now - phdStartDate;

            // Calculate progress percentage
            let progressPercentage = (elapsed / totalDuration) * 100;
            progressPercentage = Math.max(0, Math.min(100, progressPercentage));

            // Only update DOM if value has changed significantly (>0.000001)
            const formattedProgress = progressPercentage.toFixed(8);
            if (progressText.textContent !== `${formattedProgress}%`) {
                progressBar.style.width = `${progressPercentage}%`;
                progressBar.setAttribute('aria-valuenow', progressPercentage);
                progressText.textContent = `${formattedProgress}%`;
            }
        }

        // Use requestAnimationFrame for smoother updates
        function animate() {
            updateProgress();
            requestAnimationFrame(animate);
        }

        // Start the animation
        animate();
    </script>

      <!-- FuckUpMySite link -->
      <!-- <p style="text-align: center; margin-top: 20px; font-size: 12px; opacity: 0.7;">
        <a href="https://www.fuckupmysite.com/?url=https%3A%2F%2Fthibaultle.github.io&torchCursor=true&comicSans=true&fakeCursors=true&peskyFly=true" target="_blank" style="color: inherit; text-decoration: underline;">
          Tired of reading this?
        </a>
      </p> -->


      <!-- Rocket Ship Game -->
      <div id="rocketGameContainer" style="text-align: center; margin-top: 30px;">
        <div style="font-size: 12px; opacity: 0.6; line-height: 1.4;">
          <div style="margin-bottom: 5px;">• <span id="rocketBtn" style="cursor: pointer; text-decoration: underline;">Launch rocketship</span></div>
          <div>• <a href="https://www.fuckupmysite.com/?url=https%3A%2F%2Fthibaultle.github.io&torchCursor=true&comicSans=true&fakeCursors=true&peskyFly=true" target="_blank" style="color: inherit; text-decoration: underline;">Destroy this site</a></div>
        </div>
      </div>

      <script>
        // Mobile detection function
        function isMobile() {
          return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                 window.innerWidth <= 768 ||
                 window.innerHeight <= 600;
        }

        // Hide game on mobile devices
        function setupMobileDetection() {
          const container = document.getElementById('rocketGameContainer');
          if (isMobile()) {
            container.style.display = 'none';
          }
        }

        // Check on page load and window resize
        setupMobileDetection();
        window.addEventListener('resize', setupMobileDetection);

        // Rocket Ship Game - Flies over website content
        class RocketShip {
          constructor() {
            // Don't start game on mobile
            if (isMobile()) {
              return;
            }

            this.x = window.innerWidth / 2;
            this.y = window.innerHeight / 2;
            this.vx = 0;
            this.vy = 0;
            this.rotation = 0;
            this.thrust = 0;
            this.maxThrust = 0.6; // Increased from 0.4 for slightly faster movement
            this.friction = 0.95; // Increased from 0.98 for more control
            this.rotationSpeed = 0.08; // Reduced from 0.12
            this.thrustAccel = 0.02; // Increased from 0.015 for more responsive thrust
            this.engineParticles = [];
            this.bullets = [];
            this.lastShot = 0;
            this.shotCooldown = 150;
            this.score = 0;
            this.enemies = [];
            this.spawnTimer = 0;
            this.spawnRate = 2000;
            this.scrollLocked = false;
            this.stars = [];
            this.maxStars = 3;
            this.binaryStars = [];
            this.maxBinaryStars = 2;
            this.blackHoles = [];
            this.maxBlackHoles = 2;
            this.hasMoved = false;
            this.instructionPopup = null;
            this.gameOver = false;

            this.setupRocket();
            this.setupControls();
            this.setupInstructionPopup();
            this.setupScoreDisplay();
            this.setupEscNote();
            this.spawnEnemies();
            this.spawnStars();
            this.spawnBinaryStars();
            this.spawnBlackHoles();
            this.gameLoop();
          }

          setupRocket() {
            // Create simple green triangle rocket
            this.rocket = document.createElement('div');
            this.rocket.id = 'rocketShip';
            this.rocket.style.cssText = `
              position: fixed;
              width: 0;
              height: 0;
              border-left: 40px solid #4ecdc4;
              border-top: 20px solid transparent;
              border-bottom: 20px solid transparent;
              z-index: 10000;
              transform-origin: center;
              filter: drop-shadow(0 4px 15px rgba(0,0,0,0.3));
            `;

            document.body.appendChild(this.rocket);
            this.updateRocketPosition();
          }

          setupInstructionPopup() {
            this.instructionPopup = document.createElement('div');
            this.instructionPopup.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background: rgba(0, 0, 0, 0.9);
              color: white;
              padding: 20px 30px;
              border-radius: 15px;
              font-size: 18px;
              font-family: Arial, sans-serif;
              text-align: center;
              z-index: 10001;
              border: 2px solid #4ecdc4;
              box-shadow: 0 10px 30px rgba(0,0,0,0.5);
              animation: pulse 2s infinite;
            `;

            this.instructionPopup.innerHTML = `
              <div style="margin-bottom: 15px;">🚀</div>
              <div style="font-weight: bold; margin-bottom: 10px;">Welcome to Rocket Ship!</div>
              <div style="margin-bottom: 15px;">Use Arrow Keys to steer</div>
              <div style="font-size: 16px; margin-bottom: 10px; color: #4ecdc4;">Reach as many stars as possible, without falling into a black hole!</div>
              <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">Start moving to begin!</div>
            `;

            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
              @keyframes pulse {
                0%, 100% { transform: translate(-50%, -50%) scale(1); }
                50% { transform: translate(-50%, -50%) scale(1.05); }
              }
            `;
            document.head.appendChild(style);

            document.body.appendChild(this.instructionPopup);
          }

          setupScoreDisplay() {
            this.scoreDisplay = document.createElement('div');
            this.scoreDisplay.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: rgba(0, 0, 0, 0.8);
              color: white;
              padding: 15px 20px;
              border-radius: 10px;
              font-size: 18px;
              font-family: Arial, sans-serif;
              font-weight: bold;
              z-index: 10001;
              border: 2px solid #4ecdc4;
              box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            `;

            this.updateScoreDisplay();
            document.body.appendChild(this.scoreDisplay);
          }

          setupEscNote() {
            this.escNote = document.createElement('div');
            this.escNote.style.cssText = `
              position: fixed;
              bottom: 20px;
              right: 20px;
              background: rgba(0, 0, 0, 0.7);
              color: white;
              padding: 10px 15px;
              border-radius: 8px;
              font-size: 14px;
              font-family: Arial, sans-serif;
              z-index: 10001;
              border: 1px solid #4ecdc4;
              box-shadow: 0 2px 10px rgba(0,0,0,0.3);
              opacity: 0.8;
            `;

            this.escNote.innerHTML = `
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 16px;">⌨️</span>
                <span>Press Esc to close</span>
              </div>
            `;

            document.body.appendChild(this.escNote);
          }

          updateScoreDisplay() {
            this.scoreDisplay.innerHTML = `
              <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 20px;">⭐</span>
                <span>Score: ${this.score}</span>
              </div>
            `;
          }

          setupControls() {
            this.keys = {};
            document.addEventListener('keydown', (e) => {
              // Prevent default behavior for arrow keys and space to stop scrolling
              if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                e.preventDefault();
              }

              this.keys[e.code] = true;
              if (e.code === 'Escape') this.hideGame();
            });
            document.addEventListener('keyup', (e) => {
              this.keys[e.code] = false;
            });

            // Lock scroll position when game starts
            this.lockScroll();
          }

          lockScroll() {
            this.scrollLocked = true;
            // Store current scroll position
            this.scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            this.scrollY = window.pageYOffset || document.documentElement.scrollTop;

            // Prevent scrolling
            document.body.style.overflow = 'hidden';
            document.documentElement.style.overflow = 'hidden';

            // Force scroll to top
            window.scrollTo(0, 0);
          }

          unlockScroll() {
            this.scrollLocked = false;
            document.body.style.overflow = '';
            document.documentElement.style.overflow = '';
            // Restore scroll position
            window.scrollTo(this.scrollX, this.scrollY);
          }

          spawnStars() {
            for (let i = 0; i < this.maxStars; i++) {
              this.spawnStar();
            }
          }

          spawnStar() {
            const star = document.createElement('div');
            // Random size between 25px and 40px
            const size = 25 + Math.random() * 15;
            star.style.cssText = `
              position: fixed;
              width: ${size}px;
              height: ${size}px;
              background: radial-gradient(circle, #ffd700, #ffed4e);
              border: 2px solid #ffb347;
              border-radius: 50%;
              z-index: 9996;
              box-shadow: 0 0 20px #ffd700;
              animation: twinkle 1.5s infinite alternate;
            `;

            // Add twinkle animation
            const style = document.createElement('style');
            style.textContent = `
              @keyframes twinkle {
                0% { opacity: 0.7; transform: scale(1); }
                100% { opacity: 1; transform: scale(1.1); }
              }
            `;
            document.head.appendChild(style);

            // Random position
            const x = Math.random() * (window.innerWidth - 80) + 40;
            const y = Math.random() * (window.innerHeight - 80) + 40;

            // Random velocity for faster movement
            const vx = (Math.random() - 0.5) * 1.2; // -0.6 to 0.6 pixels per frame (increased from 0.5)
            const vy = (Math.random() - 0.5) * 1.2; // -0.6 to 0.6 pixels per frame (increased from 0.5)

            star.style.left = x + 'px';
            star.style.top = y + 'px';
            document.body.appendChild(star);

            // Bigger hitbox for stars (1.5x the visual size, like black holes)
            this.stars.push({ x, y, vx, vy, element: star, size: (size/2) * 1.5 });
          }

          updateStars() {
            this.stars.forEach((star, index) => {
              // Update position
              star.x += star.vx;
              star.y += star.vy;

              // Wrap around screen edges
              if (star.x < -50) star.x = window.innerWidth + 50;
              if (star.x > window.innerWidth + 50) star.x = -50;
              if (star.y < -50) star.y = window.innerHeight + 50;
              if (star.y > window.innerHeight + 50) star.y = -50;

              // Update element position
              star.element.style.left = star.x + 'px';
              star.element.style.top = star.y + 'px';
            });
          }

          spawnBinaryStars() {
            for (let i = 0; i < this.maxBinaryStars; i++) {
              this.spawnBinaryStar();
            }
          }

          spawnBinaryStar() {
            const centerX = Math.random() * (window.innerWidth - 150) + 75;
            const centerY = Math.random() * (window.innerHeight - 150) + 75;
            const orbitRadius = 30 + Math.random() * 40; // 30-70px separation
            const orbitSpeed = 0.01 + (0.03 * (30 / orbitRadius)); // Slower for wider separations
            const startAngle = Math.random() * Math.PI * 2;

            // Create big red star
            const star1 = document.createElement('div');
            const star1Size = 35;
            star1.style.cssText = `
              position: fixed;
              width: ${star1Size}px;
              height: ${star1Size}px;
              background: radial-gradient(circle, #ff4444, #cc0000);
              border: 2px solid #990000;
              border-radius: 50%;
              z-index: 9996;
              box-shadow: 0 0 25px #ff4444;
            `;

            // Create small white star
            const star2 = document.createElement('div');
            const star2Size = 18;
            star2.style.cssText = `
              position: fixed;
              width: ${star2Size}px;
              height: ${star2Size}px;
              background: radial-gradient(circle, #ffffff, #f0f0f0);
              border: 2px solid #cccccc;
              border-radius: 50%;
              z-index: 9996;
              box-shadow: 0 0 15px #ffffff;
            `;

            document.body.appendChild(star1);
            document.body.appendChild(star2);

            this.binaryStars.push({
              centerX,
              centerY,
              orbitRadius,
              orbitSpeed,
              angle: startAngle,
              star1: { element: star1, x: 0, y: 0, size: star1Size/2 },
              star2: { element: star2, x: 0, y: 0, size: star2Size/2 }
            });
          }

          spawnBlackHoles() {
            for (let i = 0; i < this.maxBlackHoles; i++) {
              this.spawnBlackHole();
            }
          }

          spawnBlackHole() {
            const blackHole = document.createElement('div');
            const size = 25 + Math.random() * 15; // 25-40px
            blackHole.style.cssText = `
              position: fixed;
              width: ${size}px;
              height: ${size}px;
              background: radial-gradient(circle, #000000, #1a1a1a);
              border: 2px solid #333333;
              border-radius: 50%;
              z-index: 9996;
              box-shadow: 0 0 20px #000000, 0 0 40px #4a4a4a;
            `;

            // Random position
            const x = Math.random() * (window.innerWidth - 80) + 40;
            const y = Math.random() * (window.innerHeight - 80) + 40;

            // Random velocity for faster movement
            const vx = (Math.random() - 0.5) * 1.0; // -0.5 to 0.5 pixels per frame (increased from 0.4)
            const vy = (Math.random() - 0.5) * 1.0; // -0.5 to 0.5 pixels per frame (increased from 0.4)

            blackHole.style.left = x + 'px';
            blackHole.style.top = y + 'px';
            document.body.appendChild(blackHole);

            // Bigger hitbox for black holes (1.5x the visual size)
            this.blackHoles.push({ x, y, vx, vy, element: blackHole, size: (size/2) * 1.5 });
          }

          updateBinaryStars() {
            this.binaryStars.forEach((binary, index) => {
              // Update orbit angle
              binary.angle += binary.orbitSpeed;

              // Calculate positions
              binary.star1.x = binary.centerX + Math.cos(binary.angle) * binary.orbitRadius;
              binary.star1.y = binary.centerY + Math.sin(binary.angle) * binary.orbitRadius;
              binary.star2.x = binary.centerX + Math.cos(binary.angle + Math.PI) * binary.orbitRadius;
              binary.star2.y = binary.centerY + Math.sin(binary.angle + Math.PI) * binary.orbitRadius;

              // Update element positions
              binary.star1.element.style.left = binary.star1.x + 'px';
              binary.star1.element.style.top = binary.star1.y + 'px';
              binary.star2.element.style.left = binary.star2.x + 'px';
              binary.star2.element.style.top = binary.star2.y + 'px';
            });
          }

          updateBlackHoles() {
            this.blackHoles.forEach((blackHole, index) => {
              // Update position
              blackHole.x += blackHole.vx;
              blackHole.y += blackHole.vy;

              // Wrap around screen edges
              if (blackHole.x < -50) blackHole.x = window.innerWidth + 50;
              if (blackHole.x > window.innerWidth + 50) blackHole.x = -50;
              if (blackHole.y < -50) blackHole.y = window.innerHeight + 50;
              if (blackHole.y > window.innerHeight + 50) blackHole.y = -50;

              // Update element position
              blackHole.element.style.left = blackHole.x + 'px';
              blackHole.element.style.top = blackHole.y + 'px';
            });
          }

          showScorePopup(x, y, points, color = '#ffff00') {
            const popup = document.createElement('div');
            popup.style.cssText = `
              position: fixed;
              left: ${x}px;
              top: ${y}px;
              color: ${color};
              font-size: 20px;
              font-weight: bold;
              font-family: Arial, sans-serif;
              z-index: 10002;
              pointer-events: none;
              animation: scorePopup 1.5s ease-out forwards;
            `;

            popup.textContent = `+${points}`;

            // Add animation CSS
            const style = document.createElement('style');
            style.textContent = `
              @keyframes scorePopup {
                0% {
                  opacity: 1;
                  transform: translateY(0) scale(1);
                }
                100% {
                  opacity: 0;
                  transform: translateY(-50px) scale(1.2);
                }
              }
            `;
            document.head.appendChild(style);

            document.body.appendChild(popup);

            // Remove popup after animation
            setTimeout(() => {
              popup.remove();
            }, 1500);
          }

          update() {
            if (this.gameOver) return;

            // Check black hole collisions first
            this.blackHoles.forEach((blackHole) => {
              const dx = this.x - blackHole.x;
              const dy = this.y - blackHole.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              // Rocket hitbox is 20px radius (matches the visual triangle size)
              if (distance < 20) {
                this.gameOver = true;
                this.showGameOverScreen();
                return;
              }
            });

            // Rotation
            if (this.keys['ArrowLeft']) this.rotation -= this.rotationSpeed;
            if (this.keys['ArrowRight']) this.rotation += this.rotationSpeed;

            // Thrust
            if (this.keys['ArrowUp']) {
              this.thrust = Math.min(this.thrust + this.thrustAccel, this.maxThrust);

              // Add more engine particles when thrusting (only if game is active)
              if (!this.gameOver && Math.random() < 0.6) { // Check if game is not over
                this.addEngineParticle();
              }
            } else {
              this.thrust = Math.max(this.thrust - this.thrustAccel * 2, 0);
            }

            // Check if rocket has moved to hide instruction popup
            if ((this.keys['ArrowUp'] || this.keys['ArrowLeft'] || this.keys['ArrowRight']) && !this.hasMoved) {
              this.hasMoved = true;
              if (this.instructionPopup) {
                this.instructionPopup.remove();
                this.instructionPopup = null;
              }
            }

            // Apply thrust
            this.vx += Math.cos(this.rotation) * this.thrust;
            this.vy += Math.sin(this.rotation) * this.thrust;

            // Apply friction
            this.vx *= this.friction;
            this.vy *= this.friction;

            // Update position
            this.x += this.vx;
            this.y += this.vy;

            // Wrap around screen edges
            if (this.x < -50) this.x = window.innerWidth + 50;
            if (this.x > window.innerWidth + 50) this.x = -50;
            if (this.y < -50) this.y = window.innerHeight + 50;
            if (this.y > window.innerHeight + 50) this.y = -50;

            // Shooting
            if (this.keys['Space'] && Date.now() - this.lastShot > this.shotCooldown) {
              this.shoot();
              this.lastShot = Date.now();
            }

            // Update bullets
            this.bullets.forEach((bullet, index) => {
              bullet.x += bullet.vx;
              bullet.y += bullet.vy;

              if (bullet.x < -10 || bullet.x > window.innerWidth + 10 ||
                  bullet.y < -10 || bullet.y > window.innerHeight + 10) {
                bullet.element.remove();
                this.bullets.splice(index, 1);
              } else {
                bullet.element.style.left = bullet.x + 'px';
                bullet.element.style.top = bullet.y + 'px';
              }
            });

            // Update engine particles
            this.engineParticles.forEach((particle, index) => {
              particle.x += particle.vx;
              particle.y += particle.vy;
              particle.life--;

              if (particle.life <= 0) {
                particle.element.remove();
                this.engineParticles.splice(index, 1);
              } else {
                particle.element.style.left = particle.x + 'px';
                particle.element.style.top = particle.y + 'px';
                particle.element.style.opacity = particle.life / 20;
              }
            });

            // Update enemies
            this.enemies.forEach((enemy, index) => {
              enemy.x += enemy.vx;
              enemy.y += enemy.vy;

              // Bounce off screen edges
              if (enemy.x <= 0 || enemy.x >= window.innerWidth) enemy.vx *= -1;
              if (enemy.y <= 0 || enemy.y >= window.innerHeight) enemy.vy *= -1;

              enemy.element.style.left = enemy.x + 'px';
              enemy.element.style.top = enemy.y + 'px';

              // Check bullet collisions
              this.bullets.forEach((bullet, bulletIndex) => {
                const dx = bullet.x - enemy.x;
                const dy = bullet.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 25) {
                  // Enemy hit
                  bullet.element.remove();
                  this.bullets.splice(bulletIndex, 1);
                  enemy.element.remove();
                  this.enemies.splice(index, 1);
                  this.score += 50;
                  this.updateScoreDisplay();
                }
              });
            });

            // Update stars
            this.updateStars();

            // Check star collisions
            this.stars.forEach((star, index) => {
              const dx = this.x - star.x;
              const dy = this.y - star.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              // Rocket hitbox is 20px radius (matches the visual triangle size)
              if (distance < star.size + 20) {
                // Collect star
                star.element.remove();
                this.stars.splice(index, 1);
                this.score += 100;
                this.showScorePopup(star.x, star.y, 100);
                this.updateScoreDisplay();

                // Spawn new star
                this.spawnStar();
              }
            });

            // Check binary star collisions
            this.binaryStars.forEach((binary, index) => {
              // Check collision with first star
              const dx1 = this.x - binary.star1.x;
              const dy1 = this.y - binary.star1.y;
              const distance1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

              // Check collision with second star
              const dx2 = this.x - binary.star2.x;
              const dy2 = this.y - binary.star2.y;
              const distance2 = Math.sqrt(dx2 * dy2 + dy2 * dy2);

              // Use actual star sizes + rocket hitbox for collision detection
              if (distance1 < binary.star1.size + 20 || distance2 < binary.star2.size + 20) {
                // Collect binary star system
                const points = 250; // Both worth 250 points
                this.score += points;

                // Show score popup
                const popupX = binary.star1.x;
                const popupY = binary.star1.y;
                this.showScorePopup(popupX, popupY, points, '#ffff00');

                // Remove stars
                binary.star1.element.remove();
                binary.star2.element.remove();
                this.binaryStars.splice(index, 1);
                this.updateScoreDisplay();

                // Spawn new binary star
                this.spawnBinaryStar();
              }
            });

            // Update binary stars
            this.updateBinaryStars();

            // Update black holes
            this.updateBlackHoles();

            // Spawn new enemies
            this.spawnTimer += 16;
            if (this.spawnTimer >= this.spawnRate) {
              this.spawnEnemy();
              this.spawnTimer = 0;
            }

            this.updateRocketPosition();
          }

          updateRocketPosition() {
            this.rocket.style.left = (this.x - 20) + 'px';
            this.rocket.style.top = (this.y - 20) + 'px';
            this.rocket.style.transform = `rotate(${this.rotation}rad)`;
          }

          shoot() {
            const bullet = document.createElement('div');
            bullet.style.cssText = `
              position: fixed;
              width: 6px;
              height: 6px;
              background: #ffff00;
              border-radius: 50%;
              z-index: 9999;
              box-shadow: 0 0 10px #ffff00;
            `;

            const bulletObj = {
              x: this.x + Math.cos(this.rotation) * 50,
              y: this.y + Math.sin(this.rotation) * 50,
              vx: Math.cos(this.rotation) * 10,
              vy: Math.sin(this.rotation) * 10,
              life: 60,
              element: bullet
            };

            bullet.style.left = bulletObj.x + 'px';
            bullet.style.top = bulletObj.y + 'px';
            document.body.appendChild(bullet);
            this.bullets.push(bulletObj);
          }

          addEngineParticle() {
            // Calculate particle position behind the rocket
            const particleX = this.x - Math.cos(this.rotation) * 40;
            const particleY = this.y - Math.sin(this.rotation) * 40;

            // Add random spread to particle position (perpendicular to rocket direction)
            const spreadAmount = (Math.random() - 0.5) * 15; // ±7.5px spread
            const spreadX = Math.sin(this.rotation) * spreadAmount;
            const spreadY = -Math.cos(this.rotation) * spreadAmount;

            const finalParticleX = particleX + spreadX;
            const finalParticleY = particleY + spreadY;

            // Calculate particle velocity (opposite to rocket direction with some spread)
            const baseSpeed = 0.5 + Math.random() * 0.5;
            const velocitySpread = (Math.random() - 0.5) * 0.3; // ±0.15 spread
            const particleVx = -Math.cos(this.rotation + velocitySpread) * baseSpeed;
            const particleVy = -Math.sin(this.rotation + velocitySpread) * baseSpeed;

            // Create particle element
            const particle = document.createElement('div');
            particle.style.cssText = `
              position: fixed;
              width: 4px;
              height: 4px;
              background: #ff6b6b;
              border-radius: 50%;
              z-index: 9998;
              box-shadow: 0 0 8px #ff6b6b;
            `;

            particle.style.left = finalParticleX + 'px';
            particle.style.top = finalParticleY + 'px';
            document.body.appendChild(particle);

            // Add particle to array
            this.engineParticles.push({
              x: finalParticleX,
              y: finalParticleY,
              vx: particleVx,
              vy: particleVy,
              life: 20,
              element: particle
            });
          }

          spawnEnemy() {
            const enemy = document.createElement('div');
            enemy.style.cssText = `
              position: fixed;
              width: 30px;
              height: 30px;
              background: radial-gradient(circle, #ff4444, #cc0000);
              border: 2px solid #990000;
              border-radius: 50%;
              z-index: 9997;
              box-shadow: 0 0 15px #ff4444;
            `;

            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;

            switch(side) {
              case 0: // top
                x = Math.random() * window.innerWidth;
                y = -30;
                vx = (Math.random() - 0.5) * 3;
                vy = Math.random() * 2 + 1;
                break;
              case 1: // right
                x = window.innerWidth + 30;
                y = Math.random() * window.innerHeight;
                vx = -Math.random() * 2 - 1;
                vy = (Math.random() - 0.5) * 2;
                break;
              case 2: // bottom
                x = Math.random() * window.innerWidth;
                y = window.innerHeight + 30;
                vx = (Math.random() - 0.5) * 3;
                vy = -Math.random() * 2 - 1;
                break;
              case 3: // left
                x = -30;
                y = Math.random() * window.innerHeight;
                vx = Math.random() * 2 + 1;
                vy = (Math.random() - 0.5) * 2;
                break;
            }

            enemy.style.left = x + 'px';
            enemy.style.top = y + 'px';
            document.body.appendChild(enemy);

            this.enemies.push({ x, y, vx, vy, element: enemy });
          }

          spawnEnemies() {
            for (let i = 0; i < 6; i++) {
              this.spawnEnemy();
            }
          }

          gameLoop() {
            this.update();
            requestAnimationFrame(() => this.gameLoop());
          }

          showGameOverScreen() {
            // Hide game elements
            this.rocket.style.display = 'none';
            this.scoreDisplay.style.display = 'none';
            this.escNote.style.display = 'none';

            // Create game over screen
            const gameOverScreen = document.createElement('div');
            gameOverScreen.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.9);
              display: flex;
              flex-direction: column;
              justify-content: center;
              align-items: center;
              z-index: 10002;
              color: white;
              font-family: Arial, sans-serif;
              text-align: center;
            `;

            gameOverScreen.innerHTML = `
              <div style="font-size: 48px; margin-bottom: 20px; color: #e74c3c;">💀</div>
              <div style="font-size: 36px; margin-bottom: 20px; font-weight: bold;">Game Over!</div>
              <div style="font-size: 24px; margin-bottom: 30px; color: #e74c3c;">You fell into a black hole!</div>
              <div style="font-size: 20px; margin-bottom: 20px;">Final Score: ${this.score}</div>
              <div style="font-size: 16px; opacity: 0.8; margin-bottom: 30px;">Press Esc to close</div>
            `;

            document.body.appendChild(gameOverScreen);

            // Add escape key listener for game over screen
            const gameOverKeyListener = (e) => {
              if (e.code === 'Escape') {
                gameOverScreen.remove();
                this.hideGame();
              }
            };
            document.addEventListener('keydown', gameOverKeyListener);

            // Store reference to remove listener later
            this.gameOverKeyListener = gameOverKeyListener;
          }

          hideGame() {
            // Remove game over key listener if it exists
            if (this.gameOverKeyListener) {
              document.removeEventListener('keydown', this.gameOverKeyListener);
              this.gameOverKeyListener = null;
            }

            // Remove all game elements
            if (this.rocket) this.rocket.remove();
            if (this.scoreDisplay) this.scoreDisplay.remove();
            if (this.escNote) this.escNote.remove();

            // Remove all bullets
            this.bullets.forEach(bullet => bullet.element.remove());
            this.bullets = [];

            // Remove all enemies
            this.enemies.forEach(enemy => enemy.element.remove());
            this.enemies = [];

            // Remove all stars
            this.stars.forEach(star => star.element.remove());
            this.stars = [];

            // Remove all binary stars
            this.binaryStars.forEach(binary => {
              binary.star1.element.remove();
              binary.star2.element.remove();
            });
            this.binaryStars = [];

            // Remove all black holes
            this.blackHoles.forEach(blackHole => blackHole.element.remove());
            this.blackHoles = [];

            // Remove all engine particles
            this.engineParticles.forEach(particle => particle.element.remove());
            this.engineParticles = [];

            // Remove instruction popup
            if (this.instructionPopup) this.instructionPopup.remove();

            // Remove game over screen if it exists
            const gameOverScreen = document.querySelector('[style*="z-index: 10002"]');
            if (gameOverScreen) gameOverScreen.remove();

            // Unlock scroll
            this.unlockScroll();

            // Reset game state
            this.gameOver = false;
            this.score = 0;

            // Show launch button again
            document.getElementById('rocketBtn').style.display = 'inline';
          }
        }

        // Game initialization
        let rocketGame = null;

        document.getElementById('rocketBtn').addEventListener('click', function() {
          // Don't start game on mobile
          if (isMobile()) {
            return;
          }

          this.style.display = 'none';
          rocketGame = new RocketShip();
        });
      </script>

    </section>






    <footer>
      <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small>
      </p>
    </footer>
  </div>
  <script src="javascripts/scale.fix.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const toggle = document.querySelector('.tdnn');
      const moon = document.querySelector('.moon');

      // Function to switch theme
      function switchTheme() {
          const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
          if (!isDark) {
              document.documentElement.setAttribute('data-theme', 'dark');
              localStorage.setItem('theme', 'dark');
              moon.classList.remove('sun');
              toggle.classList.remove('day');
          } else {
              document.documentElement.setAttribute('data-theme', 'light');
              localStorage.setItem('theme', 'light');
              moon.classList.add('sun');
              toggle.classList.add('day');
          }
      }

      // Event listener
      toggle.addEventListener('click', switchTheme);

      // Check for saved theme preference
      const currentTheme = localStorage.getItem('theme') ||
          (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');

      if (currentTheme) {
          document.documentElement.setAttribute('data-theme', currentTheme);
          if (currentTheme === 'dark') {
              moon.classList.remove('sun');
              toggle.classList.remove('day');
          } else {
              moon.classList.add('sun');
              toggle.classList.add('day');
          }
      }
    });
  </script>
</body>

</html>
